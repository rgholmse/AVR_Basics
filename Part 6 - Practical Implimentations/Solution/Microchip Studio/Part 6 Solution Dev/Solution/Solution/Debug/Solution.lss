
Solution.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00804000  00804000  00000276  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000202  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00804000  00804000  00000276  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000276  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000002a8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000038  00000000  00000000  000002e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000038fe  00000000  00000000  00000320  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002787  00000000  00000000  00003c1e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000433  00000000  00000000  000063a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000070  00000000  00000000  000067d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001f3d  00000000  00000000  00006848  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000015b  00000000  00000000  00008785  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000028  00000000  00000000  000088e0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__ctors_end>
   4:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
   8:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
   c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  10:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  14:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  18:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  1c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  20:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  24:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  28:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  2c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  30:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  34:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  38:	0c 94 d7 00 	jmp	0x1ae	; 0x1ae <__vector_14>
  3c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  40:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  44:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  48:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  4c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  50:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  54:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  58:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  5c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  60:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  64:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  68:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  6c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  70:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  74:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  78:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  7c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  80:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  84:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  88:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  8c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  90:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  94:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  98:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  9c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  a0:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
  a4:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>

000000a8 <__ctors_end>:
  a8:	11 24       	eor	r1, r1
  aa:	1f be       	out	0x3f, r1	; 63
  ac:	cf ef       	ldi	r28, 0xFF	; 255
  ae:	cd bf       	out	0x3d, r28	; 61
  b0:	df e7       	ldi	r29, 0x7F	; 127
  b2:	de bf       	out	0x3e, r29	; 62

000000b4 <__do_clear_bss>:
  b4:	20 e4       	ldi	r18, 0x40	; 64
  b6:	a0 e0       	ldi	r26, 0x00	; 0
  b8:	b0 e4       	ldi	r27, 0x40	; 64
  ba:	01 c0       	rjmp	.+2      	; 0xbe <.do_clear_bss_start>

000000bc <.do_clear_bss_loop>:
  bc:	1d 92       	st	X+, r1

000000be <.do_clear_bss_start>:
  be:	a2 30       	cpi	r26, 0x02	; 2
  c0:	b2 07       	cpc	r27, r18
  c2:	e1 f7       	brne	.-8      	; 0xbc <.do_clear_bss_loop>
  c4:	0e 94 83 00 	call	0x106	; 0x106 <main>
  c8:	0c 94 ff 00 	jmp	0x1fe	; 0x1fe <_exit>

000000cc <__bad_interrupt>:
  cc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d0 <_Z19motor_direction_seth>:



void motor_direction_set(uint8_t dir)
{
	if (dir)
  d0:	88 23       	and	r24, r24
  d2:	39 f0       	breq	.+14     	; 0xe2 <_Z19motor_direction_seth+0x12>
	{
		// Clear first, then set
		PORTC.OUTCLR = PIN0_bm;
  d4:	e0 e4       	ldi	r30, 0x40	; 64
  d6:	f4 e0       	ldi	r31, 0x04	; 4
  d8:	81 e0       	ldi	r24, 0x01	; 1
  da:	86 83       	std	Z+6, r24	; 0x06
		PORTC.OUTSET = PIN1_bm;
  dc:	82 e0       	ldi	r24, 0x02	; 2
  de:	85 83       	std	Z+5, r24	; 0x05
  e0:	08 95       	ret
	}
	else
	{
		// Clear first, then set
		PORTC.OUTCLR = PIN1_bm;
  e2:	e0 e4       	ldi	r30, 0x40	; 64
  e4:	f4 e0       	ldi	r31, 0x04	; 4
  e6:	82 e0       	ldi	r24, 0x02	; 2
  e8:	86 83       	std	Z+6, r24	; 0x06
		PORTC.OUTSET = PIN0_bm;
  ea:	81 e0       	ldi	r24, 0x01	; 1
  ec:	85 83       	std	Z+5, r24	; 0x05
  ee:	08 95       	ret

000000f0 <_Z15motor_speed_setj>:
}

void motor_speed_set(uint16_t speed)
{
	// Guard for invalid speed setting
	if (speed > 4095)
  f0:	81 15       	cp	r24, r1
  f2:	20 e1       	ldi	r18, 0x10	; 16
  f4:	92 07       	cpc	r25, r18
  f6:	10 f0       	brcs	.+4      	; 0xfc <_Z15motor_speed_setj+0xc>
	{
		speed = 4095;
  f8:	8f ef       	ldi	r24, 0xFF	; 255
  fa:	9f e0       	ldi	r25, 0x0F	; 15
	}
	
	// Update duty cycle
	TCA0.SINGLE.CMP0BUF = speed;
  fc:	80 93 38 0a 	sts	0x0A38, r24	; 0x800a38 <__TEXT_REGION_LENGTH__+0x7e0a38>
 100:	90 93 39 0a 	sts	0x0A39, r25	; 0x800a39 <__TEXT_REGION_LENGTH__+0x7e0a39>
 104:	08 95       	ret

00000106 <main>:
{
	uint8_t motor_dir = 0;
	uint16_t motor_speed = 2048;
	
	// Disable IOREG protected registers for a few clock cycles
	CCP = CCP_IOREG_gc;
 106:	88 ed       	ldi	r24, 0xD8	; 216
 108:	84 bf       	out	0x34, r24	; 52
	
	// Set the clock frequency of the AVR to 24 MHz
	CLKCTRL.OSCHFCTRLA	= CLKCTRL_FRQSEL_24M_gc; // Protected register
 10a:	84 e2       	ldi	r24, 0x24	; 36
 10c:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__TEXT_REGION_LENGTH__+0x7e0068>
	
	
    PORTA.DIRSET		= PIN0_bm			// PWM for speed control
						| PIN7_bm;			// LED
 110:	e0 e0       	ldi	r30, 0x00	; 0
 112:	f4 e0       	ldi	r31, 0x04	; 4
 114:	81 e8       	ldi	r24, 0x81	; 129
 116:	81 83       	std	Z+1, r24	; 0x01
	PORTA.PIN1CTRL		= PORT_PULLUPEN_bm;	// Button for direction control
 118:	88 e0       	ldi	r24, 0x08	; 8
 11a:	81 8b       	std	Z+17, r24	; 0x11
	
	// Set output first such that H-bridge is not on in invalid state
	motor_direction_set(motor_dir);
 11c:	80 e0       	ldi	r24, 0x00	; 0
 11e:	0e 94 68 00 	call	0xd0	; 0xd0 <_Z19motor_direction_seth>
	motor_speed_set(motor_speed);
 122:	80 e0       	ldi	r24, 0x00	; 0
 124:	98 e0       	ldi	r25, 0x08	; 8
 126:	0e 94 78 00 	call	0xf0	; 0xf0 <_Z15motor_speed_setj>
	PORTC.DIRSET		= PIN0_bm
						| PIN1_bm;
 12a:	23 e0       	ldi	r18, 0x03	; 3
 12c:	20 93 41 04 	sts	0x0441, r18	; 0x800441 <__TEXT_REGION_LENGTH__+0x7e0441>
						
	/*
		Setup TCB
	*/
	TCB0.CCMP			= 24000;				// Interrupt every 1 ms
 130:	e0 e0       	ldi	r30, 0x00	; 0
 132:	fb e0       	ldi	r31, 0x0B	; 11
 134:	80 ec       	ldi	r24, 0xC0	; 192
 136:	9d e5       	ldi	r25, 0x5D	; 93
 138:	84 87       	std	Z+12, r24	; 0x0c
 13a:	95 87       	std	Z+13, r25	; 0x0d
	TCB0.INTCTRL		= TCB_CAPT_bm;			// Enable interrupt
 13c:	81 e0       	ldi	r24, 0x01	; 1
 13e:	85 83       	std	Z+5, r24	; 0x05
	TCB0.CTRLB			= TCB_CNTMODE_INT_gc;	// Periodic interrupt mode
 140:	11 82       	std	Z+1, r1	; 0x01
	TCB0.CTRLA			= TCB_CLKSEL_DIV1_gc	// PRESCALER = DIV1
						| TCB_ENABLE_bm;
 142:	80 83       	st	Z, r24
	
	/*
		Setup ADC
	*/
	VREF.ADC0REF		= VREF_REFSEL_VDD_gc;	// VDD as ADC reference
 144:	95 e0       	ldi	r25, 0x05	; 5
 146:	90 93 b0 00 	sts	0x00B0, r25	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
	
	ADC0.MUXPOS			= ADC_MUXPOS_AIN7_gc;	// PD7
 14a:	e0 e0       	ldi	r30, 0x00	; 0
 14c:	f6 e0       	ldi	r31, 0x06	; 6
 14e:	97 e0       	ldi	r25, 0x07	; 7
 150:	90 87       	std	Z+8, r25	; 0x08
	ADC0.CTRLC			= ADC_PRESC_DIV12_gc;	// 24 MHz / 12 = 2 MHz (max freq)
 152:	22 83       	std	Z+2, r18	; 0x02
	ADC0.CTRLA			= ADC_ENABLE_bm;
 154:	80 83       	st	Z, r24
	
	/*
		Setup TCA
	*/
	TCA0.SINGLE.PER		= 4095;					// Period
 156:	e0 e0       	ldi	r30, 0x00	; 0
 158:	fa e0       	ldi	r31, 0x0A	; 10
 15a:	2f ef       	ldi	r18, 0xFF	; 255
 15c:	3f e0       	ldi	r19, 0x0F	; 15
 15e:	26 a3       	std	Z+38, r18	; 0x26
 160:	37 a3       	std	Z+39, r19	; 0x27
	TCA0.SINGLE.CTRLB	= TCA_SINGLE_CMP0EN_bm	// Waveform output enable
						| TCA_SINGLE_WGMODE_SINGLESLOPE_gc;
 162:	83 e1       	ldi	r24, 0x13	; 19
 164:	81 83       	std	Z+1, r24	; 0x01
	TCA0.SINGLE.CTRLA	= TCA_SINGLE_ENABLE_bm 
						| TCA_SINGLE_CLKSEL_DIV8_gc; // DIV 8, motor dependent
 166:	90 83       	st	Z, r25
	
	
	// Enable global interrupts
	sei();
 168:	78 94       	sei
}


int main(void)
{
	uint8_t motor_dir = 0;
 16a:	c0 e0       	ldi	r28, 0x00	; 0
	sei();
	
    while (1) 
    {
		// Check button to see if we need to change direction
		if (!(PORTA.IN & PIN1_bm))
 16c:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x7e0408>
 170:	81 fd       	sbrc	r24, 1
 172:	0f c0       	rjmp	.+30     	; 0x192 <main+0x8c>
		{
			// Invert motor direction
			motor_dir = !motor_dir;
 174:	81 e0       	ldi	r24, 0x01	; 1
 176:	c1 11       	cpse	r28, r1
 178:	80 e0       	ldi	r24, 0x00	; 0
 17a:	c8 2f       	mov	r28, r24
			motor_direction_set(motor_dir);
 17c:	0e 94 68 00 	call	0xd0	; 0xd0 <_Z19motor_direction_seth>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 180:	2f e7       	ldi	r18, 0x7F	; 127
 182:	89 ea       	ldi	r24, 0xA9	; 169
 184:	93 e0       	ldi	r25, 0x03	; 3
 186:	21 50       	subi	r18, 0x01	; 1
 188:	80 40       	sbci	r24, 0x00	; 0
 18a:	90 40       	sbci	r25, 0x00	; 0
 18c:	e1 f7       	brne	.-8      	; 0x186 <main+0x80>
 18e:	00 c0       	rjmp	.+0      	; 0x190 <main+0x8a>
 190:	00 00       	nop
			// Simple button debounce
			_delay_ms(50);
		}
		
		// Measure potentiometer value and update motor speed
		ADC0.COMMAND = ADC_STCONV_bm;
 192:	81 e0       	ldi	r24, 0x01	; 1
 194:	80 93 0a 06 	sts	0x060A, r24	; 0x80060a <__TEXT_REGION_LENGTH__+0x7e060a>
		while(!(ADC0.INTFLAGS & ADC_RESRDY_bm));
 198:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <__TEXT_REGION_LENGTH__+0x7e060d>
 19c:	80 ff       	sbrs	r24, 0
 19e:	fc cf       	rjmp	.-8      	; 0x198 <main+0x92>
		motor_speed = ADC0.RES;
 1a0:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <__TEXT_REGION_LENGTH__+0x7e0610>
 1a4:	90 91 11 06 	lds	r25, 0x0611	; 0x800611 <__TEXT_REGION_LENGTH__+0x7e0611>
		
		motor_speed_set(motor_speed);
 1a8:	0e 94 78 00 	call	0xf0	; 0xf0 <_Z15motor_speed_setj>
	
	
	// Enable global interrupts
	sei();
	
    while (1) 
 1ac:	df cf       	rjmp	.-66     	; 0x16c <main+0x66>

000001ae <__vector_14>:
    }
}


ISR(TCB0_INT_vect)
{
 1ae:	1f 92       	push	r1
 1b0:	0f 92       	push	r0
 1b2:	0f b6       	in	r0, 0x3f	; 63
 1b4:	0f 92       	push	r0
 1b6:	11 24       	eor	r1, r1
 1b8:	2f 93       	push	r18
 1ba:	8f 93       	push	r24
 1bc:	9f 93       	push	r25
	static uint16_t cnt = 0;
	
	// Clear interrupt flag
	TCB0.INTFLAGS = TCB_CAPT_bm;
 1be:	81 e0       	ldi	r24, 0x01	; 1
 1c0:	80 93 06 0b 	sts	0x0B06, r24	; 0x800b06 <__TEXT_REGION_LENGTH__+0x7e0b06>
	
	// Interrupt every 1 ms
	if (cnt == 500)
 1c4:	80 91 00 40 	lds	r24, 0x4000	; 0x804000 <__DATA_REGION_ORIGIN__>
 1c8:	90 91 01 40 	lds	r25, 0x4001	; 0x804001 <__DATA_REGION_ORIGIN__+0x1>
 1cc:	84 3f       	cpi	r24, 0xF4	; 244
 1ce:	21 e0       	ldi	r18, 0x01	; 1
 1d0:	92 07       	cpc	r25, r18
 1d2:	41 f4       	brne	.+16     	; 0x1e4 <__vector_14+0x36>
	{
		cnt = 0;
 1d4:	10 92 00 40 	sts	0x4000, r1	; 0x804000 <__DATA_REGION_ORIGIN__>
 1d8:	10 92 01 40 	sts	0x4001, r1	; 0x804001 <__DATA_REGION_ORIGIN__+0x1>
		
		// Toggle LED
		PORTA.OUTTGL = PIN7_bm;
 1dc:	80 e8       	ldi	r24, 0x80	; 128
 1de:	80 93 07 04 	sts	0x0407, r24	; 0x800407 <__TEXT_REGION_LENGTH__+0x7e0407>
 1e2:	05 c0       	rjmp	.+10     	; 0x1ee <__vector_14+0x40>
	}
	else
	{
		cnt++;
 1e4:	01 96       	adiw	r24, 0x01	; 1
 1e6:	80 93 00 40 	sts	0x4000, r24	; 0x804000 <__DATA_REGION_ORIGIN__>
 1ea:	90 93 01 40 	sts	0x4001, r25	; 0x804001 <__DATA_REGION_ORIGIN__+0x1>
	}
}
 1ee:	9f 91       	pop	r25
 1f0:	8f 91       	pop	r24
 1f2:	2f 91       	pop	r18
 1f4:	0f 90       	pop	r0
 1f6:	0f be       	out	0x3f, r0	; 63
 1f8:	0f 90       	pop	r0
 1fa:	1f 90       	pop	r1
 1fc:	18 95       	reti

000001fe <_exit>:
 1fe:	f8 94       	cli

00000200 <__stop_program>:
 200:	ff cf       	rjmp	.-2      	; 0x200 <__stop_program>
